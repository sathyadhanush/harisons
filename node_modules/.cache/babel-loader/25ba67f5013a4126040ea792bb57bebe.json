{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"allowAutoHeight\", \"children\", \"defaultHeight\", \"estimatedItemSize\", \"height\", \"onScroll\", \"overscanCount\", \"scrollOffset\", \"scrollToAlignment\", \"scrollToIndex\", \"useAverageAutoHeightEstimation\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { memo, useState, useEffect } from 'react';\nimport VirtualList from '@segment/react-tiny-virtual-list';\nimport debounce from 'lodash.debounce';\nimport PropTypes from 'prop-types';\nimport { useForceUpdate } from '../../hooks';\nimport { Pane } from '../../layers';\nvar TableVirtualBody = /*#__PURE__*/memo(function TableVirtualBody(props) {\n  var _props$allowAutoHeigh = props.allowAutoHeight,\n      allowAutoHeight = _props$allowAutoHeigh === void 0 ? false : _props$allowAutoHeigh,\n      inputChildren = props.children,\n      _props$defaultHeight = props.defaultHeight,\n      defaultHeight = _props$defaultHeight === void 0 ? 48 : _props$defaultHeight,\n      estimatedItemSize = props.estimatedItemSize,\n      paneHeight = props.height,\n      onScroll = props.onScroll,\n      _props$overscanCount = props.overscanCount,\n      overscanCount = _props$overscanCount === void 0 ? 5 : _props$overscanCount,\n      scrollOffset = props.scrollOffset,\n      scrollToAlignment = props.scrollToAlignment,\n      scrollToIndex = props.scrollToIndex,\n      _props$useAverageAuto = props.useAverageAutoHeightEstimation,\n      useAverageAutoHeightEstimation = _props$useAverageAuto === void 0 ? true : _props$useAverageAuto,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var forceUpdate = useForceUpdate();\n  var autoHeights = [];\n  var autoHeightRefs = [];\n  var averageAutoHeight = defaultHeight;\n\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      paneRef = _useState2[0],\n      setPaneRef = _useState2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isIntegerHeight = _useState4[0],\n      setIsIntegerHeight = _useState4[1];\n\n  var _useState5 = useState(0),\n      _useState6 = _slicedToArray(_useState5, 2),\n      calculatedHeight = _useState6[0],\n      setCalculatedHeight = _useState6[1];\n\n  var updateOnResize = function updateOnResize() {\n    autoHeights = [];\n    autoHeightRefs = [];\n    averageAutoHeight = defaultHeight; // Simply return when we now the height of the pane is fixed.\n\n    if (isIntegerHeight) return; // Return if we are in a weird edge case in which the ref is no longer valid.\n\n    if (paneRef && paneRef instanceof Node) {\n      var tempCalculatedHeight = paneRef.offsetHeight;\n\n      if (tempCalculatedHeight > 0) {\n        // Save the calculated height which is needed for the VirtualList.\n        setCalculatedHeight(tempCalculatedHeight); // Prevent updateOnResize being called recursively when there is a valid height.\n\n        return;\n      }\n    } // When height is still 0 (or paneRef is not valid) try recursively until success.\n\n\n    requestAnimationFrame(function () {\n      updateOnResize();\n    });\n  };\n\n  var onResize = debounce(updateOnResize, 200);\n  useEffect(function () {\n    if (props.height !== calculatedHeight) {\n      setIsIntegerHeight(Number.isInteger(props.height));\n    }\n  }, [props.height]);\n  useEffect(function () {\n    if (paneRef && paneRef instanceof Node) {\n      updateOnResize();\n    }\n  }, [paneRef]); // Mirrors functionality of componentDidMount and componentWillUnmount.\n  // By passing an empty array, will only run on first render, the function returned\n  // will be called on component unmount\n\n  useEffect(function () {\n    updateOnResize();\n    window.addEventListener('resize', onResize, false);\n    return function () {\n      window.removeEventListener('resize', onResize);\n    };\n  }, []);\n  /**\n   * This function will process all items that have height=\"auto\" set.\n   * It will loop through all refs and get calculate the height.\n   */\n\n  var processAutoHeights = function processAutoHeights() {\n    var isUpdated = false; // This will determine the averageAutoHeight.\n\n    var total = 0;\n    var totalAmount = 0; // Loop through all of the refs that have height=\"auto\".\n\n    autoHeightRefs.forEach(function (ref, index) {\n      // If the height is already calculated, skip it,\n      // but calculate the height for the total.\n      if (autoHeights[index]) {\n        total += autoHeights[index];\n        totalAmount += 1;\n        return;\n      } // Make sure the ref has a child\n\n\n      if (ref && ref.childNodes && ref.childNodes[0] && Number.isInteger(ref.childNodes[0].offsetHeight)) {\n        var height = ref.childNodes[0].offsetHeight; // Add to the total to calculate the averageAutoHeight.\n\n        total += height;\n        totalAmount += 1; // Cache the height.\n\n        autoHeights[index] = height; // Set the update flag to true.\n\n        isUpdated = true;\n      }\n    }); // Save the average height.\n\n    averageAutoHeight = total / totalAmount; // There are some new heights detected that had previously not been calculated.\n    // Call forceUpdate to make sure the virtual list renders again.\n\n    if (isUpdated) forceUpdate();\n  };\n\n  var onVirtualHelperRef = function onVirtualHelperRef(index, ref) {\n    autoHeightRefs[index] = ref;\n    requestAnimationFrame(function () {\n      processAutoHeights();\n    });\n  };\n\n  var getItemSize = function getItemSize(children) {\n    // Prefer to return a array of all heights.\n    if (!allowAutoHeight) {\n      return children.map(function (child) {\n        if (! /*#__PURE__*/React.isValidElement(child)) return defaultHeight;\n        var height = child.props.height;\n\n        if (Number.isInteger(height)) {\n          return height;\n        }\n\n        return defaultHeight;\n      });\n    } // If allowAutoHeight is true, return a function instead.\n\n\n    var itemSizeFn = function itemSizeFn(index) {\n      if (! /*#__PURE__*/React.isValidElement(children[index])) return defaultHeight;\n      var height = children[index].props.height; // When the height is number simply, simply return it.\n\n      if (Number.isInteger(height)) {\n        return height;\n      } // When allowAutoHeight is set and  the height is set to \"auto\"...\n\n\n      if (allowAutoHeight && children[index].props.height === 'auto') {\n        // ... and the height is calculated, return the calculated height.\n        if (autoHeights[index]) return autoHeights[index]; // ... if the height is not yet calculated, return the averge\n\n        if (useAverageAutoHeightEstimation) return averageAutoHeight;\n      } // Return the default height.\n\n\n      return defaultHeight;\n    };\n\n    return itemSizeFn;\n  }; // Children always needs to be an array.\n\n\n  var children = Array.isArray(inputChildren) ? inputChildren : React.Children.toArray(inputChildren);\n  var itemSize = getItemSize(children);\n  return /*#__PURE__*/React.createElement(Pane, _extends({\n    \"data-evergreen-table-body\": true,\n    ref: setPaneRef,\n    height: paneHeight,\n    flex: \"1\",\n    overflow: \"hidden\"\n  }, rest), /*#__PURE__*/React.createElement(VirtualList, {\n    height: isIntegerHeight ? paneHeight : calculatedHeight,\n    width: \"100%\",\n    estimatedItemSize: allowAutoHeight && useAverageAutoHeightEstimation ? averageAutoHeight : estimatedItemSize || null,\n    itemSize: itemSize,\n    overscanCount: overscanCount,\n    itemCount: React.Children.count(children),\n    scrollToIndex: scrollToIndex,\n    scrollOffset: scrollOffset,\n    scrollToAlignment: scrollToAlignment,\n    onScroll: onScroll,\n    renderItem: function renderItem(_ref) {\n      var index = _ref.index,\n          style = _ref.style;\n      var child = children[index];\n      var key = child.key || index;\n      var props = {\n        key: key,\n        style: style\n      }; // If some children are strings by accident, support this gracefully.\n\n      if (! /*#__PURE__*/React.isValidElement(child)) {\n        if (typeof child === 'string') {\n          return /*#__PURE__*/React.createElement(\"div\", props, child);\n        }\n\n        return /*#__PURE__*/React.createElement(\"div\", props, \"\\xA0\");\n      } // When allowing height=\"auto\" for rows, and a auto height item is\n      // rendered for the first time...\n\n\n      if (allowAutoHeight && /*#__PURE__*/React.isValidElement(child) && child.props.height === 'auto' && // ... and only when the height is not already been calculated.\n      !autoHeights[index]) {\n        // ... render the item in a helper div, the ref is used to calculate\n        // the height of its children.\n        return /*#__PURE__*/React.createElement(\"div\", _extends({\n          ref: function ref(_ref2) {\n            return onVirtualHelperRef(index, _ref2);\n          },\n          \"data-virtual-index\": index\n        }, props, {\n          style: _objectSpread({\n            opacity: 0\n          }, props.style)\n        }), child);\n      } // When allowAutoHeight is false, or when the height is known.\n      // Simply render the item.\n\n\n      return /*#__PURE__*/React.cloneElement(child, props);\n    }\n  }));\n});\nTableVirtualBody.propTypes = _objectSpread(_objectSpread({}, Pane.propTypes), {}, {\n  /**\n   * Children needs to be an array of a single node.\n   */\n  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),\n\n  /**\n   * Default height of each row.\n   * 48 is the default height of a TableRow.\n   */\n  defaultHeight: PropTypes.number,\n\n  /**\n   * When true, support `height=\"auto\"` on children being rendered.\n   * This is somewhat of an expirmental feature.\n   */\n  allowAutoHeight: PropTypes.bool,\n\n  /**\n   * The overscanCount property passed to react-tiny-virtual-list.\n   */\n  overscanCount: PropTypes.number,\n\n  /**\n   * When passed, this is used as the `estimatedItemSize` in react-tiny-virtual-list.\n   * Only when `allowAutoHeight` and`useAverageAutoHeightEstimation` are false.\n   */\n  estimatedItemSize: PropTypes.number,\n\n  /**\n   * When allowAutoHeight is true and this prop is true, the estimated height\n   * will be computed based on the average height of auto height rows.\n   */\n  useAverageAutoHeightEstimation: PropTypes.bool,\n\n  /**\n   * The scrollToIndex property passed to react-tiny-virtual-list\n   */\n  scrollToIndex: PropTypes.number,\n\n  /**\n   * The scrollOffset property passed to react-tiny-virtual-list\n   */\n  scrollOffset: PropTypes.number,\n\n  /**\n   * The scrollToAlignment property passed to react-tiny-virtual-list\n   */\n  scrollToAlignment: PropTypes.oneOf(['start', 'center', 'end', 'auto']),\n\n  /**\n   * The onScroll callback passed to react-tiny-virtual-list\n   */\n  onScroll: PropTypes.func\n});\nexport default TableVirtualBody;","map":{"version":3,"sources":["../../../src/table/src/TableVirtualBody.js"],"names":["TableVirtualBody","memo","allowAutoHeight","inputChildren","defaultHeight","estimatedItemSize","paneHeight","onScroll","overscanCount","scrollOffset","scrollToAlignment","scrollToIndex","useAverageAutoHeightEstimation","rest","props","forceUpdate","useForceUpdate","autoHeights","autoHeightRefs","averageAutoHeight","paneRef","setPaneRef","useState","isIntegerHeight","setIsIntegerHeight","calculatedHeight","setCalculatedHeight","updateOnResize","tempCalculatedHeight","requestAnimationFrame","onResize","debounce","useEffect","Number","window","processAutoHeights","isUpdated","total","totalAmount","ref","height","onVirtualHelperRef","getItemSize","React","child","itemSizeFn","children","Array","itemSize","index","style","key","opacity","Pane","PropTypes","func"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAA,KAAA,IAAA,IAAA,EAAA,QAAA,EAAA,SAAA,QAAA,OAAA;AACA,OAAA,WAAA,MAAA,kCAAA;AACA,OAAA,QAAA,MAAA,iBAAA;AACA,OAAA,SAAA,MAAA,YAAA;AACA,SAAA,cAAA,QAAA,aAAA;AACA,SAAA,IAAA,QAAA,cAAA;AAEA,IAAMA,gBAAgB,GAAA,aAAGC,IAAI,CAAC,SAAA,gBAAA,CAAA,KAAA,EAAiC;AAC7D,MAAA,qBAAA,GAaIa,KAbJ,CAAA,eAAA;AAAA,MACEZ,eADF,GAAA,qBAAA,KAAA,KAAA,CAAA,GAAA,KAAA,GAAA,qBAAA;AAAA,MAEYC,aAFZ,GAaIW,KAbJ,CAAA,QAAA;AAAA,MAAA,oBAAA,GAaIA,KAbJ,CAAA,aAAA;AAAA,MAGEV,aAHF,GAAA,oBAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,oBAAA;AAAA,MAIEC,iBAJF,GAaIS,KAbJ,CAAA,iBAAA;AAAA,MAKUR,UALV,GAaIQ,KAbJ,CAAA,MAAA;AAAA,MAMEP,QANF,GAaIO,KAbJ,CAAA,QAAA;AAAA,MAAA,oBAAA,GAaIA,KAbJ,CAAA,aAAA;AAAA,MAOEN,aAPF,GAAA,oBAAA,KAAA,KAAA,CAAA,GAAA,CAAA,GAAA,oBAAA;AAAA,MAQEC,YARF,GAaIK,KAbJ,CAAA,YAAA;AAAA,MASEJ,iBATF,GAaII,KAbJ,CAAA,iBAAA;AAAA,MAUEH,aAVF,GAaIG,KAbJ,CAAA,aAAA;AAAA,MAAA,qBAAA,GAaIA,KAbJ,CAAA,8BAAA;AAAA,MAWEF,8BAXF,GAAA,qBAAA,KAAA,KAAA,CAAA,GAAA,IAAA,GAAA,qBAAA;AAAA,MAYKC,IAZL,GAAA,wBAAA,CAAA,KAAA,EAAA,SAAA,CAAA;;AAeA,MAAME,WAAW,GAAGC,cAApB,EAAA;AACA,MAAIC,WAAW,GAAf,EAAA;AACA,MAAIC,cAAc,GAAlB,EAAA;AACA,MAAIC,iBAAiB,GAArB,aAAA;;AAEA,MAAA,SAAA,GAA8BG,QAA9B,EAAA;AAAA,MAAA,UAAA,GAAA,cAAA,CAAA,SAAA,EAAA,CAAA,CAAA;AAAA,MAAOF,OAAP,GAAA,UAAA,CAAA,CAAA,CAAA;AAAA,MAAgBC,UAAhB,GAAA,UAAA,CAAA,CAAA,CAAA;;AACA,MAAA,UAAA,GAA8CC,QAAQ,CAAtD,KAAsD,CAAtD;AAAA,MAAA,UAAA,GAAA,cAAA,CAAA,UAAA,EAAA,CAAA,CAAA;AAAA,MAAOC,eAAP,GAAA,UAAA,CAAA,CAAA,CAAA;AAAA,MAAwBC,kBAAxB,GAAA,UAAA,CAAA,CAAA,CAAA;;AACA,MAAA,UAAA,GAAgDF,QAAQ,CAAxD,CAAwD,CAAxD;AAAA,MAAA,UAAA,GAAA,cAAA,CAAA,UAAA,EAAA,CAAA,CAAA;AAAA,MAAOG,gBAAP,GAAA,UAAA,CAAA,CAAA,CAAA;AAAA,MAAyBC,mBAAzB,GAAA,UAAA,CAAA,CAAA,CAAA;;AAEA,MAAMC,cAAc,GAAG,SAAjBA,cAAiB,GAAM;AAC3BV,IAAAA,WAAW,GAAXA,EAAAA;AACAC,IAAAA,cAAc,GAAdA,EAAAA;AACAC,IAAAA,iBAAiB,GAHU,aAG3BA,CAH2B,CAK3B;;AACA,QAAA,eAAA,EAN2B,OAAA,CAQ3B;;AACA,QAAIC,OAAO,IAAIA,OAAO,YAAtB,IAAA,EAAwC;AACtC,UAAMQ,oBAAoB,GAAGR,OAAO,CAApC,YAAA;;AAEA,UAAIQ,oBAAoB,GAAxB,CAAA,EAA8B;AAC5B;AACAF,QAAAA,mBAAmB,CAFS,oBAET,CAAnBA,CAF4B,CAI5B;;AACA;AACD;AAlBwB,KAAA,CAqB3B;;;AACAG,IAAAA,qBAAqB,CAAC,YAAM;AAC1BF,MAAAA,cAAc;AADhBE,KAAqB,CAArBA;AAtBF,GAAA;;AA2BA,MAAMC,QAAQ,GAAGC,QAAQ,CAAA,cAAA,EAAzB,GAAyB,CAAzB;AAEAC,EAAAA,SAAS,CAAC,YAAM;AACd,QAAIlB,KAAK,CAALA,MAAAA,KAAJ,gBAAA,EAAuC;AACrCU,MAAAA,kBAAkB,CAACS,MAAM,CAANA,SAAAA,CAAiBnB,KAAK,CAAzCU,MAAmBS,CAAD,CAAlBT;AACD;AAHM,GAAA,EAIN,CAACV,KAAK,CAJTkB,MAIG,CAJM,CAATA;AAMAA,EAAAA,SAAS,CAAC,YAAM;AACd,QAAIZ,OAAO,IAAIA,OAAO,YAAtB,IAAA,EAAwC;AACtCO,MAAAA,cAAc;AACf;AAHM,GAAA,EAIN,CAhE0D,OAgE1D,CAJM,CAATK,CA5D6D,CAkE7D;AACA;AACA;;AACAA,EAAAA,SAAS,CAAC,YAAM;AACdL,IAAAA,cAAc;AACdO,IAAAA,MAAM,CAANA,gBAAAA,CAAAA,QAAAA,EAAAA,QAAAA,EAAAA,KAAAA;AAEA,WAAO,YAAM;AACXA,MAAAA,MAAM,CAANA,mBAAAA,CAAAA,QAAAA,EAAAA,QAAAA;AADF,KAAA;AAJO,GAAA,EAATF,EAAS,CAATA;AASA;AACF;AACA;AACA;;AACE,MAAMG,kBAAkB,GAAG,SAArBA,kBAAqB,GAAM;AAC/B,QAAIC,SAAS,GADkB,KAC/B,CAD+B,CAG/B;;AACA,QAAIC,KAAK,GAAT,CAAA;AACA,QAAIC,WAAW,GALgB,CAK/B,CAL+B,CAO/B;;AACApB,IAAAA,cAAc,CAAdA,OAAAA,CAAuB,UAAA,GAAA,EAAA,KAAA,EAAgB;AACrC;AACA;AACA,UAAID,WAAW,CAAf,KAAe,CAAf,EAAwB;AACtBoB,QAAAA,KAAK,IAAIpB,WAAW,CAApBoB,KAAoB,CAApBA;AACAC,QAAAA,WAAW,IAAXA,CAAAA;AACA;AANmC,OAAA,CASrC;;;AACA,UAAIC,GAAG,IAAIA,GAAG,CAAVA,UAAAA,IAAyBA,GAAG,CAAHA,UAAAA,CAAzBA,CAAyBA,CAAzBA,IAA8CN,MAAM,CAANA,SAAAA,CAAiBM,GAAG,CAAHA,UAAAA,CAAAA,CAAAA,EAAnE,YAAkDN,CAAlD,EAAoG;AAClG,YAAMO,MAAM,GAAGD,GAAG,CAAHA,UAAAA,CAAAA,CAAAA,EADmF,YAClG,CADkG,CAGlG;;AACAF,QAAAA,KAAK,IAALA,MAAAA;AACAC,QAAAA,WAAW,IALuF,CAKlGA,CALkG,CAOlG;;AACArB,QAAAA,WAAW,CAAXA,KAAW,CAAXA,GARkG,MAQlGA,CARkG,CAUlG;;AACAmB,QAAAA,SAAS,GAATA,IAAAA;AACD;AA9B4B,KAQ/BlB,EAR+B,CAiC/B;;AACAC,IAAAA,iBAAiB,GAAGkB,KAAK,GAlCM,WAkC/BlB,CAlC+B,CAoC/B;AACA;;AACA,QAAA,SAAA,EAAeJ,WAAW;AAtC5B,GAAA;;AAyCA,MAAM0B,kBAAkB,GAAG,SAArBA,kBAAqB,CAAA,KAAA,EAAA,GAAA,EAAgB;AACzCvB,IAAAA,cAAc,CAAdA,KAAc,CAAdA,GAAAA,GAAAA;AAEAW,IAAAA,qBAAqB,CAAC,YAAM;AAC1BM,MAAAA,kBAAkB;AADpBN,KAAqB,CAArBA;AAHF,GAAA;;AAQA,MAAMa,WAAW,GAAG,SAAdA,WAAc,CAAA,QAAA,EAAY;AAC9B;AACA,QAAI,CAAJ,eAAA,EAAsB;AACpB,aAAO,QAAQ,CAAR,GAAA,CAAa,UAAA,KAAA,EAAS;AAC3B,YAAI,EAAA,aAACC,KAAK,CAALA,cAAAA,CAAL,KAAKA,CAAL,EAAkC,OAAA,aAAA;AAClC,YAAQH,MAAR,GAAmBI,KAAK,CAAxB,KAAmBA,CAAnB,MAAA;;AAEA,YAAIX,MAAM,CAANA,SAAAA,CAAJ,MAAIA,CAAJ,EAA8B;AAC5B,iBAAA,MAAA;AACD;;AAED,eAAA,aAAA;AARF,OAAO,CAAP;AAH4B,KAAA,CAe9B;;;AACA,QAAMY,UAAU,GAAG,SAAbA,UAAa,CAAA,KAAA,EAAS;AAC1B,UAAI,EAAA,aAACF,KAAK,CAALA,cAAAA,CAAqBG,QAAQ,CAAlC,KAAkC,CAA7BH,CAAL,EAA4C,OAAA,aAAA;AAC5C,UAAQH,MAAR,GAAmBM,QAAQ,CAARA,KAAQ,CAARA,CAAnB,KAAmBA,CAFO,MAE1B,CAF0B,CAI1B;;AACA,UAAIb,MAAM,CAANA,SAAAA,CAAJ,MAAIA,CAAJ,EAA8B;AAC5B,eAAA,MAAA;AANwB,OAAA,CAS1B;;;AACA,UAAI/B,eAAe,IAAI4C,QAAQ,CAARA,KAAQ,CAARA,CAAAA,KAAAA,CAAAA,MAAAA,KAAvB,MAAA,EAAgE;AAC9D;AACA,YAAI7B,WAAW,CAAf,KAAe,CAAf,EAAwB,OAAOA,WAAW,CAFoB,KAEpB,CAAlB,CAFsC,CAI9D;;AACA,YAAA,8BAAA,EAAoC,OAAA,iBAAA;AAfZ,OAAA,CAkB1B;;;AACA,aAAA,aAAA;AAnBF,KAAA;;AAsBA,WAAA,UAAA;AAzK2D,GAmI7D,CAnI6D,CA4K7D;;;AACA,MAAM6B,QAAQ,GAAGC,KAAK,CAALA,OAAAA,CAAAA,aAAAA,IAAAA,aAAAA,GAA+CJ,KAAK,CAALA,QAAAA,CAAAA,OAAAA,CAAhE,aAAgEA,CAAhE;AAEA,MAAMK,QAAQ,GAAGN,WAAW,CAA5B,QAA4B,CAA5B;AAEA,SAAA,aACE,KAAA,CAAA,aAAA,CAAA,IAAA,EAAA,QAAA,CAAA;AAAM,iCAAN,IAAA;AAAgC,IAAA,GAAG,EAAnC,UAAA;AAAiD,IAAA,MAAM,EAAvD,UAAA;AAAqE,IAAA,IAAI,EAAzE,GAAA;AAA8E,IAAA,QAAQ,EAAC;AAAvF,GAAA,EAAA,IAAA,CAAA,EAAA,aACE,KAAA,CAAA,aAAA,CAAA,WAAA,EAAA;AACE,IAAA,MAAM,EAAEnB,eAAe,GAAA,UAAA,GADzB,gBAAA;AAEE,IAAA,KAAK,EAFP,MAAA;AAGE,IAAA,iBAAiB,EACfrB,eAAe,IAAfA,8BAAAA,GAAAA,iBAAAA,GAAwEG,iBAAiB,IAJ7F,IAAA;AAME,IAAA,QAAQ,EANV,QAAA;AAOE,IAAA,aAAa,EAPf,aAAA;AAQE,IAAA,SAAS,EAAEsC,KAAK,CAALA,QAAAA,CAAAA,KAAAA,CARb,QAQaA,CARb;AASE,IAAA,aAAa,EATf,aAAA;AAUE,IAAA,YAAY,EAVd,YAAA;AAWE,IAAA,iBAAiB,EAXnB,iBAAA;AAYE,IAAA,QAAQ,EAZV,QAAA;AAaE,IAAA,UAAU,EAAE,SAAA,UAAA,CAAA,IAAA,EAAsB;AAAA,UAAnBM,KAAmB,GAAA,IAAA,CAAnBA,KAAmB;AAAA,UAAZC,KAAY,GAAA,IAAA,CAAZA,KAAY;AAChC,UAAMN,KAAK,GAAGE,QAAQ,CAAtB,KAAsB,CAAtB;AACA,UAAMK,GAAG,GAAGP,KAAK,CAALA,GAAAA,IAAZ,KAAA;AACA,UAAM9B,KAAK,GAAG;AACZqC,QAAAA,GAAG,EADS,GAAA;AAEZD,QAAAA,KAAK,EAALA;AAFY,OAAd,CAHgC,CAQhC;;AACA,UAAI,EAAA,aAACP,KAAK,CAALA,cAAAA,CAAL,KAAKA,CAAL,EAAkC;AAChC,YAAI,OAAA,KAAA,KAAJ,QAAA,EAA+B;AAC7B,iBAAA,aAAO,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA,KAAA,EAAP,KAAO,CAAP;AACD;;AAED,eAAA,aAAO,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA,KAAA,EAAP,MAAO,CAAP;AAd8B,OAAA,CAiBhC;AACA;;;AACA,UACEzC,eAAe,IAAA,aACfyC,KAAK,CAALA,cAAAA,CADAzC,KACAyC,CADAzC,IAEA0C,KAAK,CAALA,KAAAA,CAAAA,MAAAA,KAFA1C,MAAAA,IAGA;AACA,OAACe,WAAW,CALd,KAKc,CALd,EAME;AACA;AACA;AACA,eAAA,aACE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA,QAAA,CAAA;AACE,UAAA,GAAG,EAAE,SAAA,GAAA,CAAA,KAAA,EAAG;AAAA,mBAAIwB,kBAAkB,CAAA,KAAA,EAAtB,KAAsB,CAAtB;AADV,WAAA;AAEE,gCAAoBQ;AAFtB,SAAA,EAAA,KAAA,EAAA;AAIE,UAAA,KAAK,EAAA,aAAA,CAAA;AACHG,YAAAA,OAAO,EAAE;AADN,WAAA,EAEAtC,KAAK,CAFL,KAAA;AAJP,SAAA,CAAA,EADF,KACE,CADF;AA5B8B,OAAA,CA2ChC;AACA;;;AACA,aAAA,aAAO6B,KAAK,CAALA,YAAAA,CAAAA,KAAAA,EAAP,KAAOA,CAAP;AACD;AA3DH,GAAA,CADF,CADF;AAjLF,CAA6B,CAA7B;AAoPA3C,gBAAgB,CAAhBA,SAAAA,GAAAA,aAAAA,CAAAA,aAAAA,CAAAA,EAAAA,EAIKqD,IAAI,CAJTrD,SAAAA,CAAAA,EAAAA,EAAAA,EAAAA;AAME;AACF;AACA;AACE8C,EAAAA,QAAQ,EAAEQ,SAAS,CAATA,SAAAA,CAAoB,CAACA,SAAS,CAATA,OAAAA,CAAkBA,SAAS,CAA5B,IAACA,CAAD,EAAoCA,SAAS,CAT7EtD,IASgC,CAApBsD,CATZtD;;AAWE;AACF;AACA;AACA;AACEI,EAAAA,aAAa,EAAEkD,SAAS,CAf1BtD,MAAAA;;AAiBE;AACF;AACA;AACA;AACEE,EAAAA,eAAe,EAAEoD,SAAS,CArB5BtD,IAAAA;;AAuBE;AACF;AACA;AACEQ,EAAAA,aAAa,EAAE8C,SAAS,CA1B1BtD,MAAAA;;AA4BE;AACF;AACA;AACA;AACEK,EAAAA,iBAAiB,EAAEiD,SAAS,CAhC9BtD,MAAAA;;AAkCE;AACF;AACA;AACA;AACEY,EAAAA,8BAA8B,EAAE0C,SAAS,CAtC3CtD,IAAAA;;AAwCE;AACF;AACA;AACEW,EAAAA,aAAa,EAAE2C,SAAS,CA3C1BtD,MAAAA;;AA4CE;AACF;AACA;AACES,EAAAA,YAAY,EAAE6C,SAAS,CA/CzBtD,MAAAA;;AAgDE;AACF;AACA;AACEU,EAAAA,iBAAiB,EAAE4C,SAAS,CAATA,KAAAA,CAAgB,CAAA,OAAA,EAAA,QAAA,EAAA,KAAA,EAnDrCtD,MAmDqC,CAAhBsD,CAnDrBtD;;AAoDE;AACF;AACA;AACEO,EAAAA,QAAQ,EAAE+C,SAAS,CAACC;AAvDtBvD,CAAAA,CAAAA;AA0DA,eAAA,gBAAA","sourcesContent":["import React, { memo, useState, useEffect } from 'react'\nimport VirtualList from '@segment/react-tiny-virtual-list'\nimport debounce from 'lodash.debounce'\nimport PropTypes from 'prop-types'\nimport { useForceUpdate } from '../../hooks'\nimport { Pane } from '../../layers'\n\nconst TableVirtualBody = memo(function TableVirtualBody(props) {\n  const {\n    allowAutoHeight = false,\n    children: inputChildren,\n    defaultHeight = 48,\n    estimatedItemSize,\n    height: paneHeight,\n    onScroll,\n    overscanCount = 5,\n    scrollOffset,\n    scrollToAlignment,\n    scrollToIndex,\n    useAverageAutoHeightEstimation = true,\n    ...rest\n  } = props\n\n  const forceUpdate = useForceUpdate()\n  let autoHeights = []\n  let autoHeightRefs = []\n  let averageAutoHeight = defaultHeight\n\n  const [paneRef, setPaneRef] = useState()\n  const [isIntegerHeight, setIsIntegerHeight] = useState(false)\n  const [calculatedHeight, setCalculatedHeight] = useState(0)\n\n  const updateOnResize = () => {\n    autoHeights = []\n    autoHeightRefs = []\n    averageAutoHeight = defaultHeight\n\n    // Simply return when we now the height of the pane is fixed.\n    if (isIntegerHeight) return\n\n    // Return if we are in a weird edge case in which the ref is no longer valid.\n    if (paneRef && paneRef instanceof Node) {\n      const tempCalculatedHeight = paneRef.offsetHeight\n\n      if (tempCalculatedHeight > 0) {\n        // Save the calculated height which is needed for the VirtualList.\n        setCalculatedHeight(tempCalculatedHeight)\n\n        // Prevent updateOnResize being called recursively when there is a valid height.\n        return\n      }\n    }\n\n    // When height is still 0 (or paneRef is not valid) try recursively until success.\n    requestAnimationFrame(() => {\n      updateOnResize()\n    })\n  }\n\n  const onResize = debounce(updateOnResize, 200)\n\n  useEffect(() => {\n    if (props.height !== calculatedHeight) {\n      setIsIntegerHeight(Number.isInteger(props.height))\n    }\n  }, [props.height])\n\n  useEffect(() => {\n    if (paneRef && paneRef instanceof Node) {\n      updateOnResize()\n    }\n  }, [paneRef])\n\n  // Mirrors functionality of componentDidMount and componentWillUnmount.\n  // By passing an empty array, will only run on first render, the function returned\n  // will be called on component unmount\n  useEffect(() => {\n    updateOnResize()\n    window.addEventListener('resize', onResize, false)\n\n    return () => {\n      window.removeEventListener('resize', onResize)\n    }\n  }, [])\n\n  /**\n   * This function will process all items that have height=\"auto\" set.\n   * It will loop through all refs and get calculate the height.\n   */\n  const processAutoHeights = () => {\n    let isUpdated = false\n\n    // This will determine the averageAutoHeight.\n    let total = 0\n    let totalAmount = 0\n\n    // Loop through all of the refs that have height=\"auto\".\n    autoHeightRefs.forEach((ref, index) => {\n      // If the height is already calculated, skip it,\n      // but calculate the height for the total.\n      if (autoHeights[index]) {\n        total += autoHeights[index]\n        totalAmount += 1\n        return\n      }\n\n      // Make sure the ref has a child\n      if (ref && ref.childNodes && ref.childNodes[0] && Number.isInteger(ref.childNodes[0].offsetHeight)) {\n        const height = ref.childNodes[0].offsetHeight\n\n        // Add to the total to calculate the averageAutoHeight.\n        total += height\n        totalAmount += 1\n\n        // Cache the height.\n        autoHeights[index] = height\n\n        // Set the update flag to true.\n        isUpdated = true\n      }\n    })\n\n    // Save the average height.\n    averageAutoHeight = total / totalAmount\n\n    // There are some new heights detected that had previously not been calculated.\n    // Call forceUpdate to make sure the virtual list renders again.\n    if (isUpdated) forceUpdate()\n  }\n\n  const onVirtualHelperRef = (index, ref) => {\n    autoHeightRefs[index] = ref\n\n    requestAnimationFrame(() => {\n      processAutoHeights()\n    })\n  }\n\n  const getItemSize = children => {\n    // Prefer to return a array of all heights.\n    if (!allowAutoHeight) {\n      return children.map(child => {\n        if (!React.isValidElement(child)) return defaultHeight\n        const { height } = child.props\n\n        if (Number.isInteger(height)) {\n          return height\n        }\n\n        return defaultHeight\n      })\n    }\n\n    // If allowAutoHeight is true, return a function instead.\n    const itemSizeFn = index => {\n      if (!React.isValidElement(children[index])) return defaultHeight\n      const { height } = children[index].props\n\n      // When the height is number simply, simply return it.\n      if (Number.isInteger(height)) {\n        return height\n      }\n\n      // When allowAutoHeight is set and  the height is set to \"auto\"...\n      if (allowAutoHeight && children[index].props.height === 'auto') {\n        // ... and the height is calculated, return the calculated height.\n        if (autoHeights[index]) return autoHeights[index]\n\n        // ... if the height is not yet calculated, return the averge\n        if (useAverageAutoHeightEstimation) return averageAutoHeight\n      }\n\n      // Return the default height.\n      return defaultHeight\n    }\n\n    return itemSizeFn\n  }\n\n  // Children always needs to be an array.\n  const children = Array.isArray(inputChildren) ? inputChildren : React.Children.toArray(inputChildren)\n\n  const itemSize = getItemSize(children)\n\n  return (\n    <Pane data-evergreen-table-body ref={setPaneRef} height={paneHeight} flex=\"1\" overflow=\"hidden\" {...rest}>\n      <VirtualList\n        height={isIntegerHeight ? paneHeight : calculatedHeight}\n        width=\"100%\"\n        estimatedItemSize={\n          allowAutoHeight && useAverageAutoHeightEstimation ? averageAutoHeight : estimatedItemSize || null\n        }\n        itemSize={itemSize}\n        overscanCount={overscanCount}\n        itemCount={React.Children.count(children)}\n        scrollToIndex={scrollToIndex}\n        scrollOffset={scrollOffset}\n        scrollToAlignment={scrollToAlignment}\n        onScroll={onScroll}\n        renderItem={({ index, style }) => {\n          const child = children[index]\n          const key = child.key || index\n          const props = {\n            key,\n            style\n          }\n\n          // If some children are strings by accident, support this gracefully.\n          if (!React.isValidElement(child)) {\n            if (typeof child === 'string') {\n              return <div {...props}>{child}</div>\n            }\n\n            return <div {...props}>&nbsp;</div>\n          }\n\n          // When allowing height=\"auto\" for rows, and a auto height item is\n          // rendered for the first time...\n          if (\n            allowAutoHeight &&\n            React.isValidElement(child) &&\n            child.props.height === 'auto' &&\n            // ... and only when the height is not already been calculated.\n            !autoHeights[index]\n          ) {\n            // ... render the item in a helper div, the ref is used to calculate\n            // the height of its children.\n            return (\n              <div\n                ref={ref => onVirtualHelperRef(index, ref)}\n                data-virtual-index={index}\n                {...props}\n                style={{\n                  opacity: 0,\n                  ...props.style\n                }}\n              >\n                {child}\n              </div>\n            )\n          }\n\n          // When allowAutoHeight is false, or when the height is known.\n          // Simply render the item.\n          return React.cloneElement(child, props)\n        }}\n      />\n    </Pane>\n  )\n})\n\nTableVirtualBody.propTypes = {\n  /**\n   * Composes the Pane component as the base.\n   */\n  ...Pane.propTypes,\n\n  /**\n   * Children needs to be an array of a single node.\n   */\n  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),\n\n  /**\n   * Default height of each row.\n   * 48 is the default height of a TableRow.\n   */\n  defaultHeight: PropTypes.number,\n\n  /**\n   * When true, support `height=\"auto\"` on children being rendered.\n   * This is somewhat of an expirmental feature.\n   */\n  allowAutoHeight: PropTypes.bool,\n\n  /**\n   * The overscanCount property passed to react-tiny-virtual-list.\n   */\n  overscanCount: PropTypes.number,\n\n  /**\n   * When passed, this is used as the `estimatedItemSize` in react-tiny-virtual-list.\n   * Only when `allowAutoHeight` and`useAverageAutoHeightEstimation` are false.\n   */\n  estimatedItemSize: PropTypes.number,\n\n  /**\n   * When allowAutoHeight is true and this prop is true, the estimated height\n   * will be computed based on the average height of auto height rows.\n   */\n  useAverageAutoHeightEstimation: PropTypes.bool,\n\n  /**\n   * The scrollToIndex property passed to react-tiny-virtual-list\n   */\n  scrollToIndex: PropTypes.number,\n  /**\n   * The scrollOffset property passed to react-tiny-virtual-list\n   */\n  scrollOffset: PropTypes.number,\n  /**\n   * The scrollToAlignment property passed to react-tiny-virtual-list\n   */\n  scrollToAlignment: PropTypes.oneOf(['start', 'center', 'end', 'auto']),\n  /**\n   * The onScroll callback passed to react-tiny-virtual-list\n   */\n  onScroll: PropTypes.func\n}\n\nexport default TableVirtualBody\n"]},"metadata":{},"sourceType":"module"}
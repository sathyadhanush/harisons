{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"value\", \"children\", \"onChange\", \"autoFocus\", \"spellCheck\", \"placeholder\", \"icon\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { memo, forwardRef, useCallback } from 'react';\nimport { css } from 'glamor';\nimport PropTypes from 'prop-types';\nimport { SearchIcon } from '../../icons';\nimport { IconWrapper } from '../../icons/src/IconWrapper';\nimport { Text } from '../../typography';\nimport TableHeaderCell from './TableHeaderCell';\nvar invisibleInputClass = css({\n  border: 'none',\n  backgroundColor: 'transparent',\n  WebkitAppearance: 'none',\n  MozAppearance: 'none',\n  WebkitFontSmoothing: 'antialiased',\n  '&:focus': {\n    outline: 'none'\n  },\n  '&::placeholder': {\n    color: 'rgba(67, 90, 111, 0.7)'\n  }\n}).toString();\n\nvar noop = function noop() {};\n\nvar SearchTableHeaderCell = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function SearchTableHeaderCell(props, ref) {\n  var value = props.value,\n      children = props.children,\n      _props$onChange = props.onChange,\n      onChange = _props$onChange === void 0 ? noop : _props$onChange,\n      autoFocus = props.autoFocus,\n      _props$spellCheck = props.spellCheck,\n      spellCheck = _props$spellCheck === void 0 ? true : _props$spellCheck,\n      _props$placeholder = props.placeholder,\n      placeholder = _props$placeholder === void 0 ? 'Filter...' : _props$placeholder,\n      _props$icon = props.icon,\n      icon = _props$icon === void 0 ? SearchIcon : _props$icon,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var handleChange = useCallback(function (e) {\n    return onChange(e.target.value);\n  }, [onChange]);\n  return /*#__PURE__*/React.createElement(TableHeaderCell, rest, /*#__PURE__*/React.createElement(IconWrapper, {\n    icon: icon,\n    color: \"muted\",\n    marginLeft: 2,\n    marginRight: 10,\n    size: 12\n  }), /*#__PURE__*/React.createElement(Text, {\n    is: \"input\",\n    size: 300,\n    flex: \"1\",\n    className: invisibleInputClass,\n    value: value,\n    onChange: handleChange,\n    autoFocus: autoFocus,\n    spellCheck: spellCheck,\n    fontWeight: 500,\n    marginLeft: -2,\n    paddingLeft: 0,\n    placeholder: placeholder,\n    ref: ref\n  }));\n}));\nSearchTableHeaderCell.propTypes = _objectSpread(_objectSpread({}, TableHeaderCell.propTypes), {}, {\n  /**\n   * The value of the input.\n   */\n  value: PropTypes.string,\n\n  /**\n   * Handler to be called when the input changes.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * Sets whether the component should be automatically focused on component render.\n   */\n  autoFocus: PropTypes.bool,\n\n  /**\n   * Sets whether to apply spell checking to the content.\n   */\n  spellCheck: PropTypes.bool,\n\n  /**\n   * Text to display in the input if the input is empty.\n   */\n  placeholder: PropTypes.string,\n\n  /**\n   * The Evergreen or custom icon before the label.\n   */\n  icon: PropTypes.oneOfType([PropTypes.elementType, PropTypes.element])\n});\nexport default SearchTableHeaderCell;","map":{"version":3,"sources":["../../../src/table/src/SearchTableHeaderCell.js"],"names":["invisibleInputClass","border","backgroundColor","WebkitAppearance","MozAppearance","WebkitFontSmoothing","outline","color","noop","SearchTableHeaderCell","memo","forwardRef","value","children","onChange","autoFocus","spellCheck","placeholder","icon","rest","props","handleChange","useCallback","e","ref","TableHeaderCell","PropTypes"],"mappings":"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","sourcesContent":["import React, { memo, forwardRef, useCallback } from 'react'\nimport { css } from 'glamor'\nimport PropTypes from 'prop-types'\nimport { SearchIcon } from '../../icons'\nimport { IconWrapper } from '../../icons/src/IconWrapper'\nimport { Text } from '../../typography'\nimport TableHeaderCell from './TableHeaderCell'\n\nconst invisibleInputClass = css({\n  border: 'none',\n  backgroundColor: 'transparent',\n  WebkitAppearance: 'none',\n  MozAppearance: 'none',\n  WebkitFontSmoothing: 'antialiased',\n\n  '&:focus': {\n    outline: 'none'\n  },\n\n  '&::placeholder': {\n    color: 'rgba(67, 90, 111, 0.7)'\n  }\n}).toString()\n\nconst noop = () => {}\n\nconst SearchTableHeaderCell = memo(\n  forwardRef(function SearchTableHeaderCell(props, ref) {\n    const {\n      value,\n      children,\n      onChange = noop,\n      autoFocus,\n      spellCheck = true,\n      placeholder = 'Filter...',\n      icon = SearchIcon,\n      ...rest\n    } = props\n\n    const handleChange = useCallback(e => onChange(e.target.value), [onChange])\n\n    return (\n      <TableHeaderCell {...rest}>\n        <IconWrapper icon={icon} color=\"muted\" marginLeft={2} marginRight={10} size={12} />\n        <Text\n          is=\"input\"\n          size={300}\n          flex=\"1\"\n          className={invisibleInputClass}\n          value={value}\n          onChange={handleChange}\n          autoFocus={autoFocus}\n          spellCheck={spellCheck}\n          fontWeight={500}\n          marginLeft={-2}\n          paddingLeft={0}\n          placeholder={placeholder}\n          ref={ref}\n        />\n      </TableHeaderCell>\n    )\n  })\n)\n\nSearchTableHeaderCell.propTypes = {\n  /**\n   * Composes the TableHeaderCell component as the base.\n   */\n  ...TableHeaderCell.propTypes,\n\n  /**\n   * The value of the input.\n   */\n  value: PropTypes.string,\n\n  /**\n   * Handler to be called when the input changes.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * Sets whether the component should be automatically focused on component render.\n   */\n  autoFocus: PropTypes.bool,\n\n  /**\n   * Sets whether to apply spell checking to the content.\n   */\n  spellCheck: PropTypes.bool,\n\n  /**\n   * Text to display in the input if the input is empty.\n   */\n  placeholder: PropTypes.string,\n\n  /**\n   * The Evergreen or custom icon before the label.\n   */\n  icon: PropTypes.oneOfType([PropTypes.elementType, PropTypes.element])\n}\n\nexport default SearchTableHeaderCell\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"children\", \"size\", \"disabled\", \"placeholder\", \"isSelectable\", \"textProps\", \"autoFocus\", \"onChange\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { useLatest } from '../../hooks';\nimport safeInvoke from '../../lib/safe-invoke';\nimport { Portal } from '../../portal';\nimport { Stack } from '../../stack';\nimport EditableCellField from './EditableCellField';\nimport TableCell from './TableCell';\nimport TextTableCell from './TextTableCell';\nvar emptyProps = {};\nvar EditableCell = /*#__PURE__*/memo(function EditableCell(props) {\n  var children = props.children,\n      _props$size = props.size,\n      size = _props$size === void 0 ? 300 : _props$size,\n      disabled = props.disabled,\n      placeholder = props.placeholder,\n      _props$isSelectable = props.isSelectable,\n      isSelectable = _props$isSelectable === void 0 ? true : _props$isSelectable,\n      _props$textProps = props.textProps,\n      textProps = _props$textProps === void 0 ? emptyProps : _props$textProps,\n      _props$autoFocus = props.autoFocus,\n      autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,\n      onChange = props.onChange,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var cursor = 'text';\n  var mainRef = useRef(null);\n\n  var _useState = useState(children),\n      _useState2 = _slicedToArray(_useState, 2),\n      value = _useState2[0],\n      setValue = _useState2[1];\n\n  var _useState3 = useState(autoFocus),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isEditing = _useState4[0],\n      setIsEditing = _useState4[1];\n\n  var onChangeRef = useLatest(onChange);\n  useEffect(function () {\n    setValue(children);\n  }, [children]);\n  var handleDoubleClick = useCallback(function () {\n    if (disabled || !isSelectable) return;\n    setIsEditing(true);\n  }, [disabled, isSelectable]);\n  var handleKeyDown = useCallback(function (e) {\n    if (disabled) return;\n    var key = e.key;\n    /**\n     * When the user presses a character on the keyboard, use that character\n     * as the value in the text field.\n     */\n\n    if (key === 'Enter' || key === 'Shift') {\n      setIsEditing(true);\n    } else if (key.match(/^[a-z]{0,10}$/) && !e.metaKey && !e.ctrlKey && !e.altKey) {\n      setIsEditing(true);\n      setValue(function (prev) {\n        return prev + key;\n      });\n    }\n  }, [disabled]);\n  var handleFieldChangeComplete = useCallback(function (value) {\n    setIsEditing(false);\n    setValue(value);\n    safeInvoke(onChangeRef.current, value);\n\n    if (mainRef.current && isSelectable) {\n      mainRef.current.focus();\n    }\n  }, // onChangeRef is a ref\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [isSelectable]);\n  var handleFieldCancel = useCallback(function () {\n    setIsEditing(false);\n  }, []);\n  var handleClick = useCallback(function () {\n    if (mainRef.current) {\n      mainRef.current.focus();\n    }\n  }, []);\n  var getTargetRef = useCallback(function () {\n    return mainRef.current;\n  }, []);\n\n  if (disabled) {\n    cursor = 'not-allowed';\n  } else if (isSelectable) {\n    cursor = 'default';\n  }\n\n  var lessOpacity = useMemo(function () {\n    return disabled || !value && placeholder;\n  }, [disabled, value, placeholder]);\n  var mergedTextProps = useMemo(function () {\n    return _objectSpread({\n      size: size,\n      opacity: lessOpacity ? 0.5 : 1\n    }, textProps);\n  }, [lessOpacity, size, textProps]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(TextTableCell, _extends({\n    ref: mainRef,\n    isSelectable: isSelectable,\n    onClick: handleClick,\n    onDoubleClick: handleDoubleClick,\n    onKeyDown: handleKeyDown,\n    cursor: cursor,\n    textProps: mergedTextProps\n  }, rest), value || placeholder), isEditing && /*#__PURE__*/React.createElement(Portal, null, /*#__PURE__*/React.createElement(Stack, null, function (zIndex) {\n    return /*#__PURE__*/React.createElement(EditableCellField, {\n      zIndex: zIndex,\n      getTargetRef: getTargetRef,\n      value: value,\n      onEscape: handleFieldCancel,\n      onChangeComplete: handleFieldChangeComplete,\n      onCancel: handleFieldCancel,\n      size: size\n    });\n  })));\n});\nEditableCell.propTypes = _objectSpread(_objectSpread({}, TableCell.propTypes), {}, {\n  /*\n   * Makes the TableCell focusable.\n   * Will add tabIndex={-1 || this.props.tabIndex}.\n   */\n  isSelectable: PropTypes.bool,\n\n  /**\n   * When true, the cell can't be edited.\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * Optional placeholder when children is falsy.\n   */\n  placeholder: PropTypes.node,\n\n  /**\n   * The size used for the TextTableCell and Textarea.\n   */\n  size: PropTypes.oneOf([300, 400]),\n\n  /**\n   * This is the value of the cell.\n   */\n  children: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n\n  /**\n   * Function called when value changes. (value: string) => void.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * When true, the cell will initialize in the editing state.\n   */\n  autoFocus: PropTypes.bool\n});\nexport default EditableCell;","map":{"version":3,"sources":["../../../src/table/src/EditableCell.js"],"names":["emptyProps","EditableCell","memo","children","size","disabled","placeholder","isSelectable","textProps","autoFocus","onChange","rest","props","cursor","mainRef","useRef","value","setValue","useState","isEditing","setIsEditing","onChangeRef","useLatest","useEffect","handleDoubleClick","useCallback","handleKeyDown","key","e","prev","handleFieldChangeComplete","safeInvoke","handleFieldCancel","handleClick","getTargetRef","lessOpacity","useMemo","mergedTextProps","opacity","TableCell","PropTypes","bool"],"mappings":"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","sourcesContent":["import React, { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport { useLatest } from '../../hooks'\nimport safeInvoke from '../../lib/safe-invoke'\nimport { Portal } from '../../portal'\nimport { Stack } from '../../stack'\nimport EditableCellField from './EditableCellField'\nimport TableCell from './TableCell'\nimport TextTableCell from './TextTableCell'\n\nconst emptyProps = {}\n\nconst EditableCell = memo(function EditableCell(props) {\n  const {\n    children,\n    size = 300,\n    disabled,\n    placeholder,\n    isSelectable = true,\n    textProps = emptyProps,\n    autoFocus = false,\n    onChange,\n    ...rest\n  } = props\n\n  let cursor = 'text'\n\n  const mainRef = useRef(null)\n  const [value, setValue] = useState(children)\n  const [isEditing, setIsEditing] = useState(autoFocus)\n  const onChangeRef = useLatest(onChange)\n\n  useEffect(() => {\n    setValue(children)\n  }, [children])\n\n  const handleDoubleClick = useCallback(() => {\n    if (disabled || !isSelectable) return\n\n    setIsEditing(true)\n  }, [disabled, isSelectable])\n\n  const handleKeyDown = useCallback(\n    e => {\n      if (disabled) return\n      const { key } = e\n\n      /**\n       * When the user presses a character on the keyboard, use that character\n       * as the value in the text field.\n       */\n      if (key === 'Enter' || key === 'Shift') {\n        setIsEditing(true)\n      } else if (key.match(/^[a-z]{0,10}$/) && !e.metaKey && !e.ctrlKey && !e.altKey) {\n        setIsEditing(true)\n        setValue(prev => prev + key)\n      }\n    },\n    [disabled]\n  )\n\n  const handleFieldChangeComplete = useCallback(\n    value => {\n      setIsEditing(false)\n      setValue(value)\n\n      safeInvoke(onChangeRef.current, value)\n\n      if (mainRef.current && isSelectable) {\n        mainRef.current.focus()\n      }\n    },\n    // onChangeRef is a ref\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [isSelectable]\n  )\n\n  const handleFieldCancel = useCallback(() => {\n    setIsEditing(false)\n  }, [])\n\n  const handleClick = useCallback(() => {\n    if (mainRef.current) {\n      mainRef.current.focus()\n    }\n  }, [])\n\n  const getTargetRef = useCallback(() => mainRef.current, [])\n\n  if (disabled) {\n    cursor = 'not-allowed'\n  } else if (isSelectable) {\n    cursor = 'default'\n  }\n\n  const lessOpacity = useMemo(() => disabled || (!value && placeholder), [disabled, value, placeholder])\n\n  const mergedTextProps = useMemo(\n    () => ({\n      size,\n      opacity: lessOpacity ? 0.5 : 1,\n      ...textProps\n    }),\n    [lessOpacity, size, textProps]\n  )\n  return (\n    <React.Fragment>\n      <TextTableCell\n        ref={mainRef}\n        isSelectable={isSelectable}\n        onClick={handleClick}\n        onDoubleClick={handleDoubleClick}\n        onKeyDown={handleKeyDown}\n        cursor={cursor}\n        textProps={mergedTextProps}\n        {...rest}\n      >\n        {value || placeholder}\n      </TextTableCell>\n      {isEditing && (\n        <Portal>\n          <Stack>\n            {zIndex => (\n              <EditableCellField\n                zIndex={zIndex}\n                getTargetRef={getTargetRef}\n                value={value}\n                onEscape={handleFieldCancel}\n                onChangeComplete={handleFieldChangeComplete}\n                onCancel={handleFieldCancel}\n                size={size}\n              />\n            )}\n          </Stack>\n        </Portal>\n      )}\n    </React.Fragment>\n  )\n})\n\nEditableCell.propTypes = {\n  /**\n   * Composes the TableCell component as the base.\n   */\n  ...TableCell.propTypes,\n\n  /*\n   * Makes the TableCell focusable.\n   * Will add tabIndex={-1 || this.props.tabIndex}.\n   */\n  isSelectable: PropTypes.bool,\n\n  /**\n   * When true, the cell can't be edited.\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * Optional placeholder when children is falsy.\n   */\n  placeholder: PropTypes.node,\n\n  /**\n   * The size used for the TextTableCell and Textarea.\n   */\n  size: PropTypes.oneOf([300, 400]),\n\n  /**\n   * This is the value of the cell.\n   */\n  children: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n\n  /**\n   * Function called when value changes. (value: string) => void.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * When true, the cell will initialize in the editing state.\n   */\n  autoFocus: PropTypes.bool\n}\n\nexport default EditableCell\n"]},"metadata":{},"sourceType":"module"}
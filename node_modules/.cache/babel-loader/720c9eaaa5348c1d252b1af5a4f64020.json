{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"color\", \"icon\", \"size\", \"title\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { forwardRef, memo } from 'react';\nimport PropTypes from 'prop-types';\nimport ReactIs from 'react-is';\nimport Box from 'ui-box';\n/**\n * This is an internal helper component for rendering custom or Evergreen icons\n * Box props are applied to the outer Box container, and Evergreen icon-specific props are added to the icon element.\n */\n\nexport var IconWrapper = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function Icon(_ref, ref) {\n  var color = _ref.color,\n      icon = _ref.icon,\n      size = _ref.size,\n      title = _ref.title,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  if (!icon || typeof icon === 'string') {\n    return null;\n  }\n\n  var iconProps = {\n    color: color,\n    size: size,\n    title: title\n  };\n  var iconWithProps = null;\n\n  if (ReactIs.isValidElementType(icon)) {\n    var Component = icon;\n    iconWithProps = /*#__PURE__*/React.createElement(Component, _extends({\n      ref: ref\n    }, iconProps));\n  } else if ( /*#__PURE__*/React.isValidElement(icon)) {\n    iconWithProps = /*#__PURE__*/React.cloneElement(icon, _objectSpread(_objectSpread(_objectSpread({}, iconProps), icon.props), {}, {\n      ref: ref\n    }));\n  }\n\n  return /*#__PURE__*/React.createElement(Box, _extends({\n    display: \"inline-flex\"\n  }, props), iconWithProps);\n}));\nIconWrapper.propTypes = {\n  /**\n   * Color of icon. Equivalent to setting CSS `fill` property.\n   */\n  color: PropTypes.string,\n\n  /**\n   * The icon component - whether an Evergreen icon or a custom icon node:\n   *\n   * - If `null` or `undefined` or `false`, this component will render nothing.\n   * - If given a `JSX.Element`, that element will be rendered, with size/color/title props cloned into it\n   * - If given a React element type, it will be rendered with the other icon props\n   *   As a consumer, you should never use `<IconWrapper icon={<element />}` directly; simply render `<element />` instead.\n   */\n  icon: PropTypes.oneOfType([PropTypes.elementType, PropTypes.element]),\n\n  /**\n   * Size of the icon, in pixels.\n   * Icons contains 16px and 20px SVG icon paths,\n   * and chooses the appropriate resolution based on this prop.\n   */\n  size: PropTypes.number,\n\n  /**\n   * Description string.\n   * Browsers usually render this as a tooltip on hover, whereas screen\n   * readers will use it for aural feedback.\n   * By default, this is set to the icon's name for accessibility.\n   */\n  title: PropTypes.string\n};","map":{"version":3,"sources":["../../../src/icons/src/IconWrapper.js"],"names":["IconWrapper","memo","forwardRef","color","icon","size","title","props","iconProps","iconWithProps","ReactIs","Component","ref","React","PropTypes","string"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAA,KAAA,IAAA,UAAA,EAAA,IAAA,QAAA,OAAA;AACA,OAAA,SAAA,MAAA,YAAA;AACA,OAAA,OAAA,MAAA,UAAA;AACA,OAAA,GAAA,MAAA,QAAA;AAEA;AACA;AACA;AACA;;AACA,OAAO,IAAMA,WAAW,GAAA,aAAGC,IAAI,EAAA,aAC7BC,UAAU,CAAC,SAAA,IAAA,CAAA,IAAA,EAAA,GAAA,EAA2D;AAAA,MAA3CC,KAA2C,GAAA,IAAA,CAA3CA,KAA2C;AAAA,MAApCC,IAAoC,GAAA,IAAA,CAApCA,IAAoC;AAAA,MAA9BC,IAA8B,GAAA,IAAA,CAA9BA,IAA8B;AAAA,MAAxBC,KAAwB,GAAA,IAAA,CAAxBA,KAAwB;AAAA,MAAdC,KAAc,GAAA,wBAAA,CAAA,IAAA,EAAA,SAAA,CAAA;;AACpE,MAAI,CAAA,IAAA,IAAS,OAAA,IAAA,KAAb,QAAA,EAAuC;AACrC,WAAA,IAAA;AACD;;AAED,MAAMC,SAAS,GAAG;AAChBL,IAAAA,KAAK,EADW,KAAA;AAEhBE,IAAAA,IAAI,EAFY,IAAA;AAGhBC,IAAAA,KAAK,EAALA;AAHgB,GAAlB;AAMA,MAAIG,aAAa,GAAjB,IAAA;;AACA,MAAIC,OAAO,CAAPA,kBAAAA,CAAJ,IAAIA,CAAJ,EAAsC;AACpC,QAAMC,SAAS,GAAf,IAAA;AACAF,IAAAA,aAAa,GAAA,aAAG,KAAA,CAAA,aAAA,CAAA,SAAA,EAAA,QAAA,CAAA;AAAW,MAAA,GAAG,EAAEG;AAAhB,KAAA,EAAhBH,SAAgB,CAAA,CAAhBA;AAFF,GAAA,MAGO,KAAA,aAAII,KAAK,CAALA,cAAAA,CAAJ,IAAIA,CAAJ,EAAgC;AACrCJ,IAAAA,aAAa,GAAA,aAAG,KAAK,CAAL,YAAA,CAAA,IAAA,EAAA,aAAA,CAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EAAA,SAAA,CAAA,EAA4CL,IAAI,CAAhD,KAAA,CAAA,EAAA,EAAA,EAAA;AAAwDQ,MAAAA,GAAG,EAAHA;AAAxD,KAAA,CAAA,CAAhBH;AACD;;AAED,SAAA,aACE,KAAA,CAAA,aAAA,CAAA,GAAA,EAAA,QAAA,CAAA;AAAK,IAAA,OAAO,EAAC;AAAb,GAAA,EAAA,KAAA,CAAA,EADF,aACE,CADF;AApBG,CACK,CADmB,CAAxB;AA4BPT,WAAW,CAAXA,SAAAA,GAAwB;AACtB;AACF;AACA;AACEG,EAAAA,KAAK,EAAEW,SAAS,CAJM,MAAA;;AAMtB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEV,EAAAA,IAAI,EAAEU,SAAS,CAATA,SAAAA,CAAoB,CAACA,SAAS,CAAV,WAAA,EAAwBA,SAAS,CAdrC,OAcI,CAApBA,CAdgB;;AAgBtB;AACF;AACA;AACA;AACA;AACET,EAAAA,IAAI,EAAES,SAAS,CArBO,MAAA;;AAuBtB;AACF;AACA;AACA;AACA;AACA;AACER,EAAAA,KAAK,EAAEQ,SAAS,CAACC;AA7BK,CAAxBf","sourcesContent":["import React, { forwardRef, memo } from 'react'\nimport PropTypes from 'prop-types'\nimport ReactIs from 'react-is'\nimport Box from 'ui-box'\n\n/**\n * This is an internal helper component for rendering custom or Evergreen icons\n * Box props are applied to the outer Box container, and Evergreen icon-specific props are added to the icon element.\n */\nexport const IconWrapper = memo(\n  forwardRef(function Icon({ color, icon, size, title, ...props }, ref) {\n    if (!icon || typeof icon === 'string') {\n      return null\n    }\n\n    const iconProps = {\n      color,\n      size,\n      title\n    }\n\n    let iconWithProps = null\n    if (ReactIs.isValidElementType(icon)) {\n      const Component = icon\n      iconWithProps = <Component ref={ref} {...iconProps} />\n    } else if (React.isValidElement(icon)) {\n      iconWithProps = React.cloneElement(icon, { ...iconProps, ...icon.props, ref })\n    }\n\n    return (\n      <Box display=\"inline-flex\" {...props}>\n        {iconWithProps}\n      </Box>\n    )\n  })\n)\n\nIconWrapper.propTypes = {\n  /**\n   * Color of icon. Equivalent to setting CSS `fill` property.\n   */\n  color: PropTypes.string,\n\n  /**\n   * The icon component - whether an Evergreen icon or a custom icon node:\n   *\n   * - If `null` or `undefined` or `false`, this component will render nothing.\n   * - If given a `JSX.Element`, that element will be rendered, with size/color/title props cloned into it\n   * - If given a React element type, it will be rendered with the other icon props\n   *   As a consumer, you should never use `<IconWrapper icon={<element />}` directly; simply render `<element />` instead.\n   */\n  icon: PropTypes.oneOfType([PropTypes.elementType, PropTypes.element]),\n\n  /**\n   * Size of the icon, in pixels.\n   * Icons contains 16px and 20px SVG icon paths,\n   * and chooses the appropriate resolution based on this prop.\n   */\n  size: PropTypes.number,\n\n  /**\n   * Description string.\n   * Browsers usually render this as a tooltip on hover, whereas screen\n   * readers will use it for aural feedback.\n   * By default, this is set to the icon's name for accessibility.\n   */\n  title: PropTypes.string\n}\n"]},"metadata":{},"sourceType":"module"}
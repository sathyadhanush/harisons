{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport isEmpty from 'lodash.isempty';\nimport uniqBy from 'lodash.uniqby';\nimport FileRejectionReason from '../../../constants/src/FileRejectionReason';\nimport hasValue from '../../../lib/has-value';\nimport { getAcceptedTypesMessage, getFileSizeMessage, getMaxFilesMessage } from './messages';\n/**\n * @typedef {object} FileRejection\n * @property {File} file\n * @property {string} message Informative message to display to the user for why the file was rejected\n * @property {string} reason Error code/enum to denote why the file was rejected\n */\n\n/**\n * Returns a list of objects containing rejected files and why they were rejected based on the provided options\n * @param {File[]} files\n * @param {import('./split-files').SplitFilesOptions | undefined} options\n * @returns {FileRejection[]}\n */\n\nvar getFileRejections = function getFileRejections(files, options) {\n  if (options == null || isEmpty(files)) {\n    return [];\n  }\n\n  var acceptedMimeTypes = options.acceptedMimeTypes,\n      currentCount = options.currentFileCount,\n      maxFiles = options.maxFiles,\n      maxSizeInBytes = options.maxSizeInBytes;\n  var typeRejections = files.map(function (file) {\n    if (isEmpty(acceptedMimeTypes) || acceptedMimeTypes !== null && acceptedMimeTypes !== void 0 && acceptedMimeTypes.some(function (type) {\n      return file.type === type;\n    })) {\n      return;\n    }\n\n    return {\n      file: file,\n      reason: FileRejectionReason.InvalidFileType,\n      message: \"This file is not an accepted format. \".concat(getAcceptedTypesMessage(acceptedMimeTypes))\n    };\n  });\n  var sizeRejections = files.map(function (file) {\n    if (maxSizeInBytes == null || maxSizeInBytes === 0 || file.size <= maxSizeInBytes) {\n      return;\n    }\n\n    return {\n      file: file,\n      reason: FileRejectionReason.FileTooLarge,\n      message: \"This file is too big. \".concat(getFileSizeMessage(maxSizeInBytes))\n    };\n  });\n  var countRejections = files.map(function (file, index) {\n    if (maxFiles == null) {\n      return;\n    }\n\n    var fileNumber = index + 1;\n\n    if ((currentCount !== null && currentCount !== void 0 ? currentCount : 0) + fileNumber <= maxFiles) {\n      return;\n    }\n\n    return {\n      file: file,\n      reason: FileRejectionReason.OverFileLimit,\n      message: getMaxFilesMessage(maxFiles)\n    };\n  }); // Type rejections are arguably more important than size rejections, so those will take priority\n\n  var fileRejections = [].concat(_toConsumableArray(typeRejections), _toConsumableArray(sizeRejections), _toConsumableArray(countRejections)).filter(hasValue);\n  return uniqBy(fileRejections, function (rejection) {\n    return rejection.file;\n  });\n};\n\nexport default getFileRejections;","map":{"version":3,"sources":["../../../../src/file-uploader/src/utils/get-file-rejections.js"],"names":["getFileRejections","options","isEmpty","acceptedMimeTypes","currentCount","maxFiles","maxSizeInBytes","typeRejections","file","reason","FileRejectionReason","message","getAcceptedTypesMessage","sizeRejections","getFileSizeMessage","countRejections","fileNumber","index","getMaxFilesMessage","fileRejections","uniqBy","rejection"],"mappings":";AAAA,OAAA,OAAA,MAAA,gBAAA;AACA,OAAA,MAAA,MAAA,eAAA;AACA,OAAA,mBAAA,MAAA,4CAAA;AACA,OAAA,QAAA,MAAA,wBAAA;AACA,SAAA,uBAAA,EAAA,kBAAA,EAAA,kBAAA,QAAA,YAAA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMA,iBAAiB,GAAG,SAApBA,iBAAoB,CAAA,KAAA,EAAA,OAAA,EAAoB;AAC5C,MAAIC,OAAO,IAAPA,IAAAA,IAAmBC,OAAO,CAA9B,KAA8B,CAA9B,EAAuC;AACrC,WAAA,EAAA;AACD;;AAED,MAAQC,iBAAR,GAAwFF,OAAxF,CAAA,iBAAA;AAAA,MAA6CG,YAA7C,GAAwFH,OAAxF,CAAA,gBAAA;AAAA,MAA2DI,QAA3D,GAAwFJ,OAAxF,CAAA,QAAA;AAAA,MAAqEK,cAArE,GAAwFL,OAAxF,CAAA,cAAA;AAEA,MAAMM,cAAc,GAAG,KAAK,CAAL,GAAA,CAAU,UAAA,IAAA,EAAQ;AACvC,QAAIL,OAAO,CAAPA,iBAAO,CAAPA,IAA8B,iBAA9BA,KAAAA,IAA8B,IAAA,iBAA9BA,KAAAA,KAAAA,CAA8B,IAAA,iBAAiB,CAAjB,IAAA,CAAwB,UAAA,IAAA,EAAI;AAAA,aAAIM,IAAI,CAAJA,IAAAA,KAAJ,IAAA;AAA9D,KAAkC,CAAlC,EAAuF;AACrF;AACD;;AAED,WAAO;AACLA,MAAAA,IAAI,EADC,IAAA;AAELC,MAAAA,MAAM,EAAEC,mBAAmB,CAFtB,eAAA;AAGLC,MAAAA,OAAO,EAAA,wCAAA,MAAA,CAA0CC,uBAAuB,CAAjE,iBAAiE,CAAjE;AAHF,KAAP;AALF,GAAuB,CAAvB;AAYA,MAAMC,cAAc,GAAG,KAAK,CAAL,GAAA,CAAU,UAAA,IAAA,EAAQ;AACvC,QAAIP,cAAc,IAAdA,IAAAA,IAA0BA,cAAc,KAAxCA,CAAAA,IAAkDE,IAAI,CAAJA,IAAAA,IAAtD,cAAA,EAAmF;AACjF;AACD;;AAED,WAAO;AACLA,MAAAA,IAAI,EADC,IAAA;AAELC,MAAAA,MAAM,EAAEC,mBAAmB,CAFtB,YAAA;AAGLC,MAAAA,OAAO,EAAA,yBAAA,MAAA,CAA2BG,kBAAkB,CAA7C,cAA6C,CAA7C;AAHF,KAAP;AALF,GAAuB,CAAvB;AAYA,MAAMC,eAAe,GAAG,KAAK,CAAL,GAAA,CAAU,UAAA,IAAA,EAAA,KAAA,EAAiB;AACjD,QAAIV,QAAQ,IAAZ,IAAA,EAAsB;AACpB;AACD;;AAED,QAAMW,UAAU,GAAGC,KAAK,GAAxB,CAAA;;AAEA,QAAI,CAACb,YAAD,KAAA,IAACA,IAAAA,YAAD,KAAA,KAAA,CAACA,GAAD,YAACA,GAAD,CAAA,IAAA,UAAA,IAAJ,QAAA,EAAkD;AAChD;AACD;;AAED,WAAO;AACLI,MAAAA,IAAI,EADC,IAAA;AAELC,MAAAA,MAAM,EAAEC,mBAAmB,CAFtB,aAAA;AAGLC,MAAAA,OAAO,EAAEO,kBAAkB,CAAA,QAAA;AAHtB,KAAP;AA1C0C,GA+BpB,CAAxB,CA/B4C,CAiD5C;;AACA,MAAMC,cAAc,GAAG,GAAA,MAAA,CAAA,kBAAA,CAAA,cAAA,CAAA,EAAA,kBAAA,CAAA,cAAA,CAAA,EAAA,kBAAA,CAAA,eAAA,CAAA,EAAA,MAAA,CAAvB,QAAuB,CAAvB;AACA,SAAOC,MAAM,CAAA,cAAA,EAAiB,UAAA,SAAA,EAAS;AAAA,WAAIC,SAAS,CAAb,IAAA;AAAvC,GAAa,CAAb;AAnDF,CAAA;;AAsDA,eAAA,iBAAA","sourcesContent":["import isEmpty from 'lodash.isempty'\nimport uniqBy from 'lodash.uniqby'\nimport FileRejectionReason from '../../../constants/src/FileRejectionReason'\nimport hasValue from '../../../lib/has-value'\nimport { getAcceptedTypesMessage, getFileSizeMessage, getMaxFilesMessage } from './messages'\n\n/**\n * @typedef {object} FileRejection\n * @property {File} file\n * @property {string} message Informative message to display to the user for why the file was rejected\n * @property {string} reason Error code/enum to denote why the file was rejected\n */\n\n/**\n * Returns a list of objects containing rejected files and why they were rejected based on the provided options\n * @param {File[]} files\n * @param {import('./split-files').SplitFilesOptions | undefined} options\n * @returns {FileRejection[]}\n */\nconst getFileRejections = (files, options) => {\n  if (options == null || isEmpty(files)) {\n    return []\n  }\n\n  const { acceptedMimeTypes, currentFileCount: currentCount, maxFiles, maxSizeInBytes } = options\n\n  const typeRejections = files.map(file => {\n    if (isEmpty(acceptedMimeTypes) || acceptedMimeTypes?.some(type => file.type === type)) {\n      return\n    }\n\n    return {\n      file,\n      reason: FileRejectionReason.InvalidFileType,\n      message: `This file is not an accepted format. ${getAcceptedTypesMessage(acceptedMimeTypes)}`\n    }\n  })\n\n  const sizeRejections = files.map(file => {\n    if (maxSizeInBytes == null || maxSizeInBytes === 0 || file.size <= maxSizeInBytes) {\n      return\n    }\n\n    return {\n      file,\n      reason: FileRejectionReason.FileTooLarge,\n      message: `This file is too big. ${getFileSizeMessage(maxSizeInBytes)}`\n    }\n  })\n\n  const countRejections = files.map((file, index) => {\n    if (maxFiles == null) {\n      return\n    }\n\n    const fileNumber = index + 1\n\n    if ((currentCount ?? 0) + fileNumber <= maxFiles) {\n      return\n    }\n\n    return {\n      file,\n      reason: FileRejectionReason.OverFileLimit,\n      message: getMaxFilesMessage(maxFiles)\n    }\n  })\n\n  // Type rejections are arguably more important than size rejections, so those will take priority\n  const fileRejections = [...typeRejections, ...sizeRejections, ...countRejections].filter(hasValue)\n  return uniqBy(fileRejections, rejection => rejection.file)\n}\n\nexport default getFileRejections\n"]},"metadata":{},"sourceType":"module"}
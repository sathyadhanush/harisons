{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"animationDuration\", \"bringFocusInside\", \"children\", \"content\", \"display\", \"minHeight\", \"minWidth\", \"onBodyClick\", \"onClose\", \"onCloseComplete\", \"onOpen\", \"onOpenComplete\", \"position\", \"shouldCloseOnExternalClick\", \"shouldCloseOnEscapePress\", \"statelessProps\", \"trigger\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { memo, forwardRef, useRef, useState, useEffect, useImperativeHandle, useCallback, useMemo } from 'react';\nimport cx from 'classnames';\nimport { css as glamorCss } from 'glamor';\nimport PropTypes from 'prop-types';\nimport { Position } from '../../constants';\nimport { useMergedRef } from '../../hooks';\nimport { Positioner } from '../../positioner';\nimport { Tooltip } from '../../tooltip';\nimport PopoverStateless from './PopoverStateless';\n\nvar noop = function noop() {};\n\nvar emptyProps = {};\nvar Popover = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function Popover(_ref, forwardedRef) {\n  var _ref$animationDuratio = _ref.animationDuration,\n      animationDuration = _ref$animationDuratio === void 0 ? 300 : _ref$animationDuratio,\n      _ref$bringFocusInside = _ref.bringFocusInside,\n      shouldBringFocusInside = _ref$bringFocusInside === void 0 ? false : _ref$bringFocusInside,\n      children = _ref.children,\n      content = _ref.content,\n      display = _ref.display,\n      _ref$minHeight = _ref.minHeight,\n      minHeight = _ref$minHeight === void 0 ? 40 : _ref$minHeight,\n      _ref$minWidth = _ref.minWidth,\n      minWidth = _ref$minWidth === void 0 ? 200 : _ref$minWidth,\n      _ref$onBodyClick = _ref.onBodyClick,\n      onBodyClick = _ref$onBodyClick === void 0 ? noop : _ref$onBodyClick,\n      _ref$onClose = _ref.onClose,\n      onClose = _ref$onClose === void 0 ? noop : _ref$onClose,\n      _ref$onCloseComplete = _ref.onCloseComplete,\n      onCloseComplete = _ref$onCloseComplete === void 0 ? noop : _ref$onCloseComplete,\n      _ref$onOpen = _ref.onOpen,\n      onOpen = _ref$onOpen === void 0 ? noop : _ref$onOpen,\n      _ref$onOpenComplete = _ref.onOpenComplete,\n      onOpenComplete = _ref$onOpenComplete === void 0 ? noop : _ref$onOpenComplete,\n      _ref$position = _ref.position,\n      position = _ref$position === void 0 ? Position.BOTTOM : _ref$position,\n      _ref$shouldCloseOnExt = _ref.shouldCloseOnExternalClick,\n      shouldCloseOnExternalClick = _ref$shouldCloseOnExt === void 0 ? true : _ref$shouldCloseOnExt,\n      _ref$shouldCloseOnEsc = _ref.shouldCloseOnEscapePress,\n      shouldCloseOnEscapePress = _ref$shouldCloseOnEsc === void 0 ? true : _ref$shouldCloseOnEsc,\n      _ref$statelessProps = _ref.statelessProps,\n      statelessProps = _ref$statelessProps === void 0 ? emptyProps : _ref$statelessProps,\n      _ref$trigger = _ref.trigger,\n      trigger = _ref$trigger === void 0 ? 'click' : _ref$trigger,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  var _useState = useState(props.isShown),\n      _useState2 = _slicedToArray(_useState, 2),\n      isShown = _useState2[0],\n      setIsShown = _useState2[1];\n\n  var popoverNode = useRef();\n  var setPopoverNode = useMergedRef(popoverNode);\n  var targetRef = useRef();\n  var setTargetRef = useMergedRef(targetRef);\n  /**\n   * Methods borrowed from BlueprintJS\n   * https://github.com/palantir/blueprint/blob/release/2.0.0/packages/core/src/components/overlay/overlay.tsx\n   */\n\n  var bringFocusInside = useCallback(function (e) {\n    if (isShown && e) {\n      e.preventDefault();\n    } // Always delay focus manipulation to just before repaint to prevent scroll jumping\n\n\n    return requestAnimationFrame(function () {\n      // Container ref may be undefined between component mounting and Portal rendering\n      // ActiveElement may be undefined in some rare cases in IE\n      if (popoverNode.current == null || // eslint-disable-line eqeqeq, no-eq-null\n      document.activeElement == null || // eslint-disable-line eqeqeq, no-eq-null\n      !isShown) {\n        return;\n      }\n\n      var isFocusOutsideModal = !popoverNode.current.contains(document.activeElement);\n\n      if (isFocusOutsideModal) {\n        // Element marked autofocus has higher priority than the other elements\n        var autofocusElement = popoverNode.current.querySelector('[autofocus]:not([disabled])');\n\n        if (autofocusElement) {\n          // Return early to avoid unnecessary dom queries\n          return autofocusElement.focus();\n        }\n\n        var wrapperElement = popoverNode.current.querySelector('[tabindex]:not([disabled])');\n\n        if (wrapperElement) {\n          return wrapperElement.focus();\n        }\n\n        var buttonElements = popoverNode.current.querySelectorAll('button:not([disabled]), a:not([disabled]), [role=\"menuitem\"]:not([disabled]), [role=\"menuitemradio\"]:not([disabled])');\n\n        if (buttonElements.length > 0) {\n          return buttonElements[0].focus();\n        }\n      }\n    });\n  }, [isShown, popoverNode.current]);\n  var bringFocusBackToTarget = useCallback(function () {\n    return requestAnimationFrame(function () {\n      if (targetRef.current == null || // eslint-disable-line eqeqeq, no-eq-null\n      popoverNode.current == null || // eslint-disable-line eqeqeq, no-eq-null\n      document.activeElement == null // eslint-disable-line eqeqeq, no-eq-null\n      ) {\n          return;\n        }\n\n      var isFocusInsideModal = popoverNode.current.contains(document.activeElement); // Bring back focus on the target.\n\n      if (document.activeElement === document.body || isFocusInsideModal) {\n        targetRef.current.focus();\n      }\n    });\n  }, [popoverNode.current, targetRef.current]);\n  var open = useCallback(function () {\n    if (isShown) {\n      return;\n    }\n\n    setIsShown(true);\n    onOpen();\n  }, [setIsShown, onOpen, isShown]);\n  var close = useCallback(function () {\n    if (!isShown) {\n      return;\n    }\n\n    setIsShown(false);\n    bringFocusBackToTarget();\n    onClose();\n  }, [setIsShown, bringFocusBackToTarget, onClose, isShown]);\n  useImperativeHandle(forwardedRef, function () {\n    return {\n      open: open,\n      close: close\n    };\n  }, [open, close]); // If `props.isShown` is a boolean, treat as a controlled component\n  // `open` and `close` should be applied when it changes\n\n  useEffect(function () {\n    if (typeof props.isShown !== 'boolean' || props.isShown === isShown) {\n      return;\n    }\n\n    if (props.isShown) {\n      open();\n    } else {\n      close();\n    }\n  }, [props.isShown, isShown]);\n  var toggle = useCallback(function () {\n    return isShown ? close() : open();\n  }, [isShown, close, open]);\n  var handleOpenHover = useMemo(function () {\n    return trigger === 'hover' ? open : undefined;\n  }, [trigger, open]);\n  var handleCloseHover = useMemo(function () {\n    return trigger === 'hover' ? close : undefined;\n  }, [trigger, close]);\n  var handleKeyDown = useCallback(function (event) {\n    return event.key === 'ArrowDown' ? bringFocusInside(event) : undefined;\n  }, [bringFocusInside]);\n  var onEsc = useCallback(function (event) {\n    return event.key === 'Escape' && shouldCloseOnEscapePress ? close() : undefined;\n  }, [shouldCloseOnEscapePress, close]);\n  var handleBodyClick = useCallback(function (event) {\n    // Ignore clicks on the popover or button\n    if (targetRef.current && targetRef.current.contains(event.target)) {\n      return;\n    }\n\n    if (popoverNode.current && popoverNode.current.contains(event.target)) {\n      return;\n    } // Notify body click\n\n\n    onBodyClick(event);\n\n    if (shouldCloseOnExternalClick !== false) {\n      close();\n    }\n  }, [onBodyClick, shouldCloseOnExternalClick, close, targetRef.current, popoverNode.current]);\n  var handleOpenComplete = useCallback(function () {\n    if (shouldBringFocusInside) bringFocusInside();\n    onOpenComplete();\n  }, [shouldBringFocusInside, bringFocusInside, onOpenComplete]);\n  useEffect(function () {\n    if (isShown) {\n      document.body.addEventListener('click', handleBodyClick, false);\n      document.body.addEventListener('keydown', onEsc, false);\n    } else {\n      document.body.removeEventListener('click', handleBodyClick, false);\n      document.body.removeEventListener('keydown', onEsc, false);\n    }\n\n    return function () {\n      document.body.removeEventListener('click', handleBodyClick, false);\n      document.body.removeEventListener('keydown', onEsc, false);\n    };\n  }, [isShown, handleBodyClick, onEsc]);\n  var renderTarget = useCallback(function (_ref2) {\n    var getRef = _ref2.getRef,\n        isShown = _ref2.isShown;\n    var isTooltipInside = children && children.type === Tooltip;\n\n    var getTargetRef = function getTargetRef(ref) {\n      setTargetRef(ref);\n      getRef(ref);\n    };\n    /**\n     * When a function is passed, you can control the Popover manually.\n     */\n\n\n    if (typeof children === 'function') {\n      return children({\n        getRef: getTargetRef,\n        isShown: isShown,\n        toggle: toggle\n      });\n    }\n\n    var popoverTargetProps = {\n      onClick: toggle,\n      onMouseEnter: handleOpenHover,\n      onKeyDown: handleKeyDown,\n      role: 'button',\n      'aria-expanded': isShown,\n      'aria-haspopup': true\n    };\n    /**\n     * Tooltips can be used within a Popover (not the other way around)\n     * In this case the children is the Tooltip instead of a button.\n     * Pass the properties to the Tooltip and let the Tooltip\n     * add the properties to the target.\n     */\n\n    if (isTooltipInside) {\n      return /*#__PURE__*/React.cloneElement(children, {\n        popoverProps: _objectSpread({\n          getTargetRef: getTargetRef,\n          isShown: isShown\n        }, popoverTargetProps)\n      });\n    }\n    /**\n     * With normal usage only popover props end up on the target.\n     */\n\n\n    return /*#__PURE__*/React.cloneElement(children, _objectSpread({\n      ref: getTargetRef\n    }, popoverTargetProps));\n  }, [children, setTargetRef, toggle, handleOpenHover, handleKeyDown]); // If `props.isShown` is a boolean, popover is controlled manually, not via mouse events\n\n  var shown = typeof props.isShown === 'boolean' ? props.isShown : isShown;\n  var contentToRender = useMemo(function () {\n    return typeof content === 'function' ? content({\n      close: close\n    }) : content;\n  }, [content, close]);\n  return /*#__PURE__*/React.createElement(Positioner, {\n    target: renderTarget,\n    isShown: shown,\n    position: position,\n    animationDuration: animationDuration,\n    onOpenComplete: handleOpenComplete,\n    onCloseComplete: onCloseComplete\n  }, function (_ref3) {\n    var css = _ref3.css,\n        getRef = _ref3.getRef,\n        state = _ref3.state,\n        style = _ref3.style;\n    return /*#__PURE__*/React.createElement(PopoverStateless, _extends({\n      ref: function ref(_ref4) {\n        setPopoverNode(_ref4);\n        getRef(_ref4);\n      },\n      \"data-state\": state,\n      display: display,\n      minWidth: minWidth,\n      minHeight: minHeight\n    }, statelessProps, {\n      className: cx(statelessProps.className, glamorCss(css, style, statelessProps.style).toString()) // Overwrite `statelessProps.style` since we are including it via className\n      ,\n      style: undefined,\n      onMouseLeave: handleCloseHover\n    }), contentToRender);\n  });\n}));\nPopover.propTypes = {\n  /**\n   * The position the Popover is on. Smart positioning might override this.\n   */\n  position: PropTypes.oneOf([Position.TOP, Position.TOP_LEFT, Position.TOP_RIGHT, Position.BOTTOM, Position.BOTTOM_LEFT, Position.BOTTOM_RIGHT, Position.LEFT, Position.RIGHT]),\n\n  /**\n   * When true, the Popover is manually shown.\n   */\n  isShown: PropTypes.bool,\n\n  /**\n   * Open the Popover based on click or hover. Default is click.\n   */\n  trigger: PropTypes.oneOf(['click', 'hover']),\n\n  /**\n   * The content of the Popover.\n   */\n  content: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,\n\n  /**\n   * The target button of the Popover.\n   * When a function the following arguments are passed:\n   * ({ toggle: Function -> Void, getRef: Function -> Ref, isShown: Bool })\n   */\n  children: PropTypes.oneOfType([PropTypes.element, PropTypes.func]).isRequired,\n\n  /**\n   * The display property passed to the Popover card.\n   */\n  display: PropTypes.string,\n\n  /**\n   * The min width of the Popover card.\n   */\n  minWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * The min height of the Popover card.\n   */\n  minHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * Properties passed through to the Popover card.\n   */\n  statelessProps: PropTypes.shape(PopoverStateless.propTypes),\n\n  /**\n   * Duration of the animation.\n   */\n  animationDuration: PropTypes.number,\n\n  /**\n   * Function called when the Popover opens.\n   */\n  onOpen: PropTypes.func,\n\n  /**\n   * Function fired when Popover closes.\n   */\n  onClose: PropTypes.func,\n\n  /**\n   * Function that will be called when the enter transition is complete.\n   */\n  onOpenComplete: PropTypes.func,\n\n  /**\n   * Function that will be called when the exit transition is complete.\n   */\n  onCloseComplete: PropTypes.func,\n\n  /**\n   * Function that will be called when the body is clicked.\n   */\n  onBodyClick: PropTypes.func,\n\n  /**\n   * When true, bring focus inside of the Popover on open.\n   */\n  bringFocusInside: PropTypes.bool,\n\n  /**\n   * Boolean indicating if clicking outside the dialog should close the dialog.\n   */\n  shouldCloseOnExternalClick: PropTypes.bool,\n\n  /**\n   * Boolean indicating if pressing the esc key should close the dialog.\n   */\n  shouldCloseOnEscapePress: PropTypes.bool\n};\nexport default Popover;","map":{"version":3,"sources":["../../../src/popover/src/Popover.js"],"names":["css","noop","emptyProps","Popover","memo","forwardRef","animationDuration","bringFocusInside","shouldBringFocusInside","children","content","display","minHeight","minWidth","onBodyClick","onClose","onCloseComplete","onOpen","onOpenComplete","position","Position","BOTTOM","shouldCloseOnExternalClick","shouldCloseOnEscapePress","statelessProps","trigger","props","isShown","setIsShown","useState","popoverNode","useRef","setPopoverNode","useMergedRef","targetRef","setTargetRef","useCallback","e","requestAnimationFrame","document","isFocusOutsideModal","autofocusElement","wrapperElement","buttonElements","bringFocusBackToTarget","isFocusInsideModal","open","close","useImperativeHandle","useEffect","toggle","handleOpenHover","useMemo","handleCloseHover","handleKeyDown","event","onEsc","handleBodyClick","handleOpenComplete","renderTarget","getRef","isTooltipInside","getTargetRef","popoverTargetProps","onClick","onMouseEnter","onKeyDown","role","popoverProps","ref","shown","contentToRender","state","style","cx","glamorCss","PropTypes","PopoverStateless","bool"],"mappings":"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","sourcesContent":["import React, { memo, forwardRef, useRef, useState, useEffect, useImperativeHandle, useCallback, useMemo } from 'react'\nimport cx from 'classnames'\nimport { css as glamorCss } from 'glamor'\nimport PropTypes from 'prop-types'\nimport { Position } from '../../constants'\nimport { useMergedRef } from '../../hooks'\nimport { Positioner } from '../../positioner'\nimport { Tooltip } from '../../tooltip'\nimport PopoverStateless from './PopoverStateless'\n\nconst noop = () => {}\nconst emptyProps = {}\n\nconst Popover = memo(\n  forwardRef(function Popover(\n    {\n      animationDuration = 300,\n      bringFocusInside: shouldBringFocusInside = false,\n      children,\n      content,\n      display,\n      minHeight = 40,\n      minWidth = 200,\n      onBodyClick = noop,\n      onClose = noop,\n      onCloseComplete = noop,\n      onOpen = noop,\n      onOpenComplete = noop,\n      position = Position.BOTTOM,\n      shouldCloseOnExternalClick = true,\n      shouldCloseOnEscapePress = true,\n      statelessProps = emptyProps,\n      trigger = 'click',\n      ...props\n    },\n    forwardedRef\n  ) {\n    const [isShown, setIsShown] = useState(props.isShown)\n    const popoverNode = useRef()\n    const setPopoverNode = useMergedRef(popoverNode)\n    const targetRef = useRef()\n    const setTargetRef = useMergedRef(targetRef)\n\n    /**\n     * Methods borrowed from BlueprintJS\n     * https://github.com/palantir/blueprint/blob/release/2.0.0/packages/core/src/components/overlay/overlay.tsx\n     */\n    const bringFocusInside = useCallback(\n      e => {\n        if (isShown && e) {\n          e.preventDefault()\n        }\n        // Always delay focus manipulation to just before repaint to prevent scroll jumping\n\n        return requestAnimationFrame(() => {\n          // Container ref may be undefined between component mounting and Portal rendering\n\n          // ActiveElement may be undefined in some rare cases in IE\n\n          if (\n            popoverNode.current == null || // eslint-disable-line eqeqeq, no-eq-null\n            document.activeElement == null || // eslint-disable-line eqeqeq, no-eq-null\n            !isShown\n          ) {\n            return\n          }\n\n          const isFocusOutsideModal = !popoverNode.current.contains(document.activeElement)\n          if (isFocusOutsideModal) {\n            // Element marked autofocus has higher priority than the other elements\n            const autofocusElement = popoverNode.current.querySelector('[autofocus]:not([disabled])')\n            if (autofocusElement) {\n              // Return early to avoid unnecessary dom queries\n              return autofocusElement.focus()\n            }\n\n            const wrapperElement = popoverNode.current.querySelector('[tabindex]:not([disabled])')\n            if (wrapperElement) {\n              return wrapperElement.focus()\n            }\n\n            const buttonElements = popoverNode.current.querySelectorAll(\n              'button:not([disabled]), a:not([disabled]), [role=\"menuitem\"]:not([disabled]), [role=\"menuitemradio\"]:not([disabled])'\n            )\n            if (buttonElements.length > 0) {\n              return buttonElements[0].focus()\n            }\n          }\n        })\n      },\n      [isShown, popoverNode.current]\n    )\n\n    const bringFocusBackToTarget = useCallback(() => {\n      return requestAnimationFrame(() => {\n        if (\n          targetRef.current == null || // eslint-disable-line eqeqeq, no-eq-null\n          popoverNode.current == null || // eslint-disable-line eqeqeq, no-eq-null\n          document.activeElement == null // eslint-disable-line eqeqeq, no-eq-null\n        ) {\n          return\n        }\n\n        const isFocusInsideModal = popoverNode.current.contains(document.activeElement)\n\n        // Bring back focus on the target.\n        if (document.activeElement === document.body || isFocusInsideModal) {\n          targetRef.current.focus()\n        }\n      })\n    }, [popoverNode.current, targetRef.current])\n\n    const open = useCallback(() => {\n      if (isShown) {\n        return\n      }\n\n      setIsShown(true)\n      onOpen()\n    }, [setIsShown, onOpen, isShown])\n\n    const close = useCallback(() => {\n      if (!isShown) {\n        return\n      }\n\n      setIsShown(false)\n      bringFocusBackToTarget()\n      onClose()\n    }, [setIsShown, bringFocusBackToTarget, onClose, isShown])\n\n    useImperativeHandle(\n      forwardedRef,\n      () => ({\n        open,\n        close\n      }),\n      [open, close]\n    )\n\n    // If `props.isShown` is a boolean, treat as a controlled component\n    // `open` and `close` should be applied when it changes\n    useEffect(() => {\n      if (typeof props.isShown !== 'boolean' || props.isShown === isShown) {\n        return\n      }\n\n      if (props.isShown) {\n        open()\n      } else {\n        close()\n      }\n    }, [props.isShown, isShown])\n\n    const toggle = useCallback(() => {\n      return isShown ? close() : open()\n    }, [isShown, close, open])\n\n    const handleOpenHover = useMemo(() => {\n      return trigger === 'hover' ? open : undefined\n    }, [trigger, open])\n\n    const handleCloseHover = useMemo(() => {\n      return trigger === 'hover' ? close : undefined\n    }, [trigger, close])\n\n    const handleKeyDown = useCallback(\n      event => {\n        return event.key === 'ArrowDown' ? bringFocusInside(event) : undefined\n      },\n      [bringFocusInside]\n    )\n\n    const onEsc = useCallback(\n      event => {\n        return event.key === 'Escape' && shouldCloseOnEscapePress ? close() : undefined\n      },\n      [shouldCloseOnEscapePress, close]\n    )\n\n    const handleBodyClick = useCallback(\n      event => {\n        // Ignore clicks on the popover or button\n        if (targetRef.current && targetRef.current.contains(event.target)) {\n          return\n        }\n\n        if (popoverNode.current && popoverNode.current.contains(event.target)) {\n          return\n        }\n\n        // Notify body click\n        onBodyClick(event)\n\n        if (shouldCloseOnExternalClick !== false) {\n          close()\n        }\n      },\n      [onBodyClick, shouldCloseOnExternalClick, close, targetRef.current, popoverNode.current]\n    )\n\n    const handleOpenComplete = useCallback(() => {\n      if (shouldBringFocusInside) bringFocusInside()\n      onOpenComplete()\n    }, [shouldBringFocusInside, bringFocusInside, onOpenComplete])\n\n    useEffect(() => {\n      if (isShown) {\n        document.body.addEventListener('click', handleBodyClick, false)\n        document.body.addEventListener('keydown', onEsc, false)\n      } else {\n        document.body.removeEventListener('click', handleBodyClick, false)\n        document.body.removeEventListener('keydown', onEsc, false)\n      }\n\n      return () => {\n        document.body.removeEventListener('click', handleBodyClick, false)\n        document.body.removeEventListener('keydown', onEsc, false)\n      }\n    }, [isShown, handleBodyClick, onEsc])\n\n    const renderTarget = useCallback(\n      ({ getRef, isShown }) => {\n        const isTooltipInside = children && children.type === Tooltip\n\n        const getTargetRef = ref => {\n          setTargetRef(ref)\n          getRef(ref)\n        }\n\n        /**\n         * When a function is passed, you can control the Popover manually.\n         */\n        if (typeof children === 'function') {\n          return children({\n            getRef: getTargetRef,\n            isShown,\n            toggle\n          })\n        }\n\n        const popoverTargetProps = {\n          onClick: toggle,\n          onMouseEnter: handleOpenHover,\n          onKeyDown: handleKeyDown,\n          role: 'button',\n          'aria-expanded': isShown,\n          'aria-haspopup': true\n        }\n\n        /**\n         * Tooltips can be used within a Popover (not the other way around)\n         * In this case the children is the Tooltip instead of a button.\n         * Pass the properties to the Tooltip and let the Tooltip\n         * add the properties to the target.\n         */\n        if (isTooltipInside) {\n          return React.cloneElement(children, {\n            popoverProps: {\n              getTargetRef,\n              isShown,\n\n              // These propeties will be spread as `popoverTargetProps`\n              // in the Tooltip component.\n              ...popoverTargetProps\n            }\n          })\n        }\n\n        /**\n         * With normal usage only popover props end up on the target.\n         */\n        return React.cloneElement(children, {\n          ref: getTargetRef,\n          ...popoverTargetProps\n        })\n      },\n      [children, setTargetRef, toggle, handleOpenHover, handleKeyDown]\n    )\n\n    // If `props.isShown` is a boolean, popover is controlled manually, not via mouse events\n    const shown = typeof props.isShown === 'boolean' ? props.isShown : isShown\n\n    const contentToRender = useMemo(() => {\n      return typeof content === 'function' ? content({ close }) : content\n    }, [content, close])\n\n    return (\n      <Positioner\n        target={renderTarget}\n        isShown={shown}\n        position={position}\n        animationDuration={animationDuration}\n        onOpenComplete={handleOpenComplete}\n        onCloseComplete={onCloseComplete}\n      >\n        {({ css, getRef, state, style }) => (\n          <PopoverStateless\n            ref={ref => {\n              setPopoverNode(ref)\n              getRef(ref)\n            }}\n            data-state={state}\n            display={display}\n            minWidth={minWidth}\n            minHeight={minHeight}\n            {...statelessProps}\n            className={cx(statelessProps.className, glamorCss(css, style, statelessProps.style).toString())}\n            // Overwrite `statelessProps.style` since we are including it via className\n            style={undefined}\n            onMouseLeave={handleCloseHover}\n          >\n            {contentToRender}\n          </PopoverStateless>\n        )}\n      </Positioner>\n    )\n  })\n)\n\nPopover.propTypes = {\n  /**\n   * The position the Popover is on. Smart positioning might override this.\n   */\n  position: PropTypes.oneOf([\n    Position.TOP,\n    Position.TOP_LEFT,\n    Position.TOP_RIGHT,\n    Position.BOTTOM,\n    Position.BOTTOM_LEFT,\n    Position.BOTTOM_RIGHT,\n    Position.LEFT,\n    Position.RIGHT\n  ]),\n\n  /**\n   * When true, the Popover is manually shown.\n   */\n  isShown: PropTypes.bool,\n  /**\n   * Open the Popover based on click or hover. Default is click.\n   */\n  trigger: PropTypes.oneOf(['click', 'hover']),\n\n  /**\n   * The content of the Popover.\n   */\n  content: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,\n\n  /**\n   * The target button of the Popover.\n   * When a function the following arguments are passed:\n   * ({ toggle: Function -> Void, getRef: Function -> Ref, isShown: Bool })\n   */\n  children: PropTypes.oneOfType([PropTypes.element, PropTypes.func]).isRequired,\n\n  /**\n   * The display property passed to the Popover card.\n   */\n  display: PropTypes.string,\n\n  /**\n   * The min width of the Popover card.\n   */\n  minWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * The min height of the Popover card.\n   */\n  minHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * Properties passed through to the Popover card.\n   */\n  statelessProps: PropTypes.shape(PopoverStateless.propTypes),\n\n  /**\n   * Duration of the animation.\n   */\n  animationDuration: PropTypes.number,\n\n  /**\n   * Function called when the Popover opens.\n   */\n  onOpen: PropTypes.func,\n\n  /**\n   * Function fired when Popover closes.\n   */\n  onClose: PropTypes.func,\n\n  /**\n   * Function that will be called when the enter transition is complete.\n   */\n  onOpenComplete: PropTypes.func,\n\n  /**\n   * Function that will be called when the exit transition is complete.\n   */\n  onCloseComplete: PropTypes.func,\n\n  /**\n   * Function that will be called when the body is clicked.\n   */\n  onBodyClick: PropTypes.func,\n\n  /**\n   * When true, bring focus inside of the Popover on open.\n   */\n  bringFocusInside: PropTypes.bool,\n\n  /**\n   * Boolean indicating if clicking outside the dialog should close the dialog.\n   */\n  shouldCloseOnExternalClick: PropTypes.bool,\n\n  /**\n   * Boolean indicating if pressing the esc key should close the dialog.\n   */\n  shouldCloseOnEscapePress: PropTypes.bool\n}\n\nexport default Popover\n"]},"metadata":{},"sourceType":"module"}